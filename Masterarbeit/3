




























it=1; acc=1e-2; boundary= 'robin'; krang  = [6.]; cloc0 = 0; cloc1 = 1; cloc2 = 1; resolution = 100; coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)	
ls = []
rs2 = []
k=6.
print k
cglob = -1j*k
cloc = cloc0+ cloc1*k+cloc2*k**2
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus, calT = True, calQ = True)
calculate_continuity_constant(gq, lq)
calculate_inf_sup_constant2(gq, lq)	
calculate_lambda_min(gq, lq)	
d = gq["d"]
u = d.solve(mus)
bases = create_bases(gq, lq, num_testvecs=20, transfer = 'robin', target_accuracy = acc, calC = False)
rssum2 = 0
for space in gq["spaces"]:
	ldict = lq[space]
	basis = bases[space]
	M = ldict["range_product"]._matrix
	S = ldict["source_product"]._matrix
	M_sparse = scipy.sparse.csr_matrix(M)
	T = ldict["transfer_matrix_robin"]
	B = basis._array.T
	T1 = T - B.dot(B.conj().T).dot(M_sparse.dot(T))
	maxval = operator_svd2(T1, S, M_sparse)[0][0]
	rssum2 += maxval**2
ru = reconstruct_solution(gq,lq,bases)
print (gq["continuity_constant"]/gq["inf_sup_constant"])*4*np.sqrt(rssum2)



























from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

k=6.
cglob= -6j
cloc=1.-0.17j
resolution = 100
coarse_grid_resolution = 10
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
p = helmholtz(boundary = 'robin')

set_log_levels(levels={'pymor': 'WARN'})

gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus, calT = True, calQ = True)
bases = create_bases(gq, lq, num_testvecs=20, transfer = 'robin', target_accuracy = 1e-2, calC = True)
ru = reconstruct_solution(gq,lq,bases, silent = False)
d = gq["d"]
u = d.solve(mus)
dif = u-ru
print d.h1_norm(dif)[0]/d.h1_norm(u)[0]

rssum2 = 0
for space in gq["spaces"]:
	ldict = lq[space]
	basis = bases[space]
	M = ldict["range_product"]._matrix
	S = ldict["source_product"]._matrix
	M_sparse = scipy.sparse.csr_matrix(M)
	T = ldict["transfer_matrix_robin"]
	B = basis._array.T
	T1 = T - B.dot(B.conj().T).dot(M_sparse.dot(T))
	maxval = operator_svd2(T1, S, M_sparse)[0][0]
	rssum2 += maxval**2
print (gq["continuity_constant"]/gq["inf_sup_constant"])*4*np.sqrt(rssum2)












from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})
it = 1

n=15
k=0
cglob = 0
resolution = 50
coarse_grid_resolution = 10
rang = np.concatenate((-np.logspace(10,1,10),np.logspace(0,10,11)))
err_r = np.zeros((len(rang),len(rang)))
xi = 0
for x in rang:
	yi = 0
	for y in rang:
		c = x+1j*y
		print c
		p = h_problem(c=c)
		gq, lq = localize_problem(p, coarse_grid_resolution, resolution)
		d = gq["d"]
		u = d.solve()
		e_r = []
		for i in range(it):
			#print i,
			#sys.stdout.flush()
			bases = create_bases2(gq,lq,n,transfer = 'robin')
			ru_r = reconstruct_solution(gq, lq, bases)
			del bases
			dif_r = u-ru_r
			e_r.append(d.h1_norm(dif_r)[0]/d.h1_norm(u)[0])
		err_r[xi][yi]=np.mean(e_r)
		yi+=1
	xi+=1
X,Y = np.meshgrid(rang, rang)
data = np.vstack([X.T.ravel(),Y.T.ravel(),err_r.ravel()]).T
open("dats/koerztest.dat", "w").writelines([" ".join(map(str, v)) + "\n" for v in data])



rang2 = np.arange(-10,11)
X,Y = np.meshgrid(rang2, rang2)
data = np.vstack([X.T.ravel(),Y.T.ravel(),err_r.ravel()]).T
open("dats/koerztest2.dat", "w").writelines([" ".join(map(str, v)) + "\n" for v in data])











from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})
it = 10

n=15
k=0
cglob = 0
resolution = 50
coarse_grid_resolution = 10
#rang = np.concatenate((-np.logspace(10,1,10),np.logspace(0,10,11)))
#rang = np.logspace(5,6,10)
rang = np.arange(-2,2,0.2)
err_r = []
xi = 0
for c in rang:
	print c
	p = poisson_problem(c=c)	
	#p = h_problem(c=c)
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution)
	d = gq["d"]
	u = d.solve()
	e_r = []
	for i in range(it):
		#print i,
		#sys.stdout.flush()
		bases = create_bases2(gq,lq,n,transfer = 'robin')
		ru_r = reconstruct_solution(gq, lq, bases)
		del bases
		dif_r = u-ru_r
		e_r.append(d.h1_norm(dif_r)[0]/d.h1_norm(u)[0])
	err_r.append(np.mean(e_r))
es = []
for i in range(it):
	bases = create_bases2(gq,lq,n,transfer = 'dirichlet')
	ru_r = reconstruct_solution(gq, lq, bases)
	dif_r = u-ru_r
	e = d.h1_norm(dif_r)[0]/d.h1_norm(u)[0]
	print e
	es.append(e)
em = np.mean(es)
from matplotlib import pyplot as plt
plt.figure()
#plt.loglog(rang, err_r, label = "err")
plt.semilogy(rang, err_r, label = "err")
plt.legend(loc='upper right')
plt.xlabel('c')
#plt.xscale('symlog')
#plt.hlines(em,1e5,1e6)
#plt.hlines(em,-1e10,1e10)
plt.hlines(em,-5,5)
plt.show()

data = np.vstack([rang, err_r]).T
open("dats/koerzreal.dat", "w").writelines([" ".join(map(str, v)) + "\n" for v in data])

rang2 = np.arange(-10,11)
data = np.vstack([rang2, err_r, np.full(len(rang2),em)]).T
open("dats/koerzreal2.dat", "w").writelines([" ".join(map(str, v)) + "\n" for v in data])



























from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

num_testvecs= 20
boundary= 'robin'
cglob = -6j
cloc = 1.0-0.5j
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
resolution = 100
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus, calQ = True, calT = True)
d = gq["d"]
u = d.solve(mus)
#bases = create_bases(gq, lq, num_testvecs, transfer = 'robin', target_accuracy = 1e-0, calC = True)
tolerances = np.logspace(-10,5,10)
ERR = []
for tol in tolerances:
	print tol
	bases = create_bases(gq, lq, num_testvecs, transfer = 'robin', target_accuracy = tol,testlimit = tol*0.129, calC = False)
	err = []
	for space in gq["spaces"]:
		ldict = lq[space]
		basis = bases[space]
		M = ldict["range_product"]._matrix
		S = ldict["source_product"]._matrix
		M_sparse = scipy.sparse.csr_matrix(M)
		T = ldict["transfer_matrix_robin"]
		B = basis._array.T
		T1 = T - B.dot(B.conj().T).dot(M_sparse.dot(T))
		maxval = operator_svd2(T1, S, M_sparse)[0][0]
		err.append(maxval)
	ERR.append(err)
mean = np.mean(ERR, axis = 1)
from matplotlib import pyplot as plt
plt.figure()
plt.loglog(tolerances, mean, label = "err")
plt.loglog(tolerances, tolerances, label = "y=x")
plt.legend(loc='upper right')
plt.xlabel('tol')
plt.gca().invert_xaxis()
plt.show()

data = np.vstack([tolerances, mean]).T
open("dats/localtol.dat", "w").writelines([" ".join(map(str, v)) + "\n" for v in data])

























from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

num_testvecs= 20
boundary= 'neumann'
save = 'test3.dat'
cglob = 0
cloc = 0
k=2
plot = True
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
space = np.logspace(-15,0,10)
err = []
for prob in space:
	print prob
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus, calQ = True)
	d = gq["d"]
	u = d.solve(mus)
	bases = create_bases(gq, lq, num_testvecs, transfer = 'robin', target_accuracy = 1e-2, max_failure_probability = prob, calC = True)
	ru = reconstruct_solution(gq, lq, bases)
	err.append(d.h1_norm(u-ru)[0]/d.h1_norm(u)[0])
from matplotlib import pyplot as plt
plt.figure()
plt.loglog(space, err, label = "err")
plt.legend(loc='upper right')
plt.xlabel('prob')
plt.show()














from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary= 'robin'
cglob = -6j
cloc = 1.-.5j
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
resolution = 200
p = helmholtz(boundary = boundary)
space = [5, 8, 10, 20, 25, 40, 50]
err = []
for coarse_grid_resolution in space:
	print coarse_grid_resolution
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus)
	d = gq["d"]
	u = d.solve(mus)
	bases = create_bases2(gq, lq, 10, transfer = 'robin')
	ru = reconstruct_solution(gq, lq, bases)
	err.append(d.h1_norm(u-ru)[0]/d.h1_norm(u)[0])
from matplotlib import pyplot as plt
plt.figure()
plt.semilogy(space, err, label = "err")
plt.legend(loc='upper right')
plt.xlabel('cgr')
plt.show()























from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary= 'robin'
k=50
cloc0 = 0
cloc1 = 0.02*(5-1j)
cloc2 = 0.0016*(8-1j)
cloc = cloc0+ cloc1*k+cloc2*k**2
cglob = -1j*k
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
plot = True
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
space = np.arange(20,200,20)
err = []
for resolution in space:
	print resolution
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus)
	d = gq["d"]
	u = d.solve(mus)
	E = []
	for i in range(10):
		bases = create_bases2(gq, lq, 30, transfer = 'robin')
		ru = reconstruct_solution(gq, lq, bases)
		E.append(d.h1_norm(u-ru)[0]/d.h1_norm(u)[0])
	err.append(E)
errs = np.mean(err, axis = 1)
from matplotlib import pyplot as plt
plt.figure()
plt.plot(space, errs, label = "err")
plt.legend(loc='upper right')
plt.xlabel('res')
plt.show()



























from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'neumann'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

import time

A = []
B = []
C = []
#D = []
K = np.arange(0,10,.1)
for k in K:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
	bases = create_bases2(gq, lq, 15, silent = False)
	t = time.time()
	a = calculate_inf_sup_constant(gq, lq, bases)
	print time.time()-t, a
	t = time.time()
	b = calculate_inf_sup_constant2(gq, lq)
	print time.time()-t, b
	t = time.time()
	c = calculate_continuity_constant(gq, lq)
	print time.time()-t, c
	#t = time.time()
	#d = calculate_continuity_constant2(gq, lq, bases)
	#print time.time()-t, d
	A.append(a)
	B.append(b)
	C.append(c)
	#D.append(d)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, A, label = "inf-sup-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

plt.figure()
plt.plot(K, B, label = "inf-sup-constant2")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

plt.figure()
plt.plot(K, C, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

"""
plt.figure()
plt.plot(K, D, label = "continuity-constant2")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()
"""





from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, A, label = "inf-sup-constant")
plt.plot(K, B, label = "inf-sup-constant2")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()










from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=0
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 15, silent = False)

import time

A = []
B = []
K = np.arange(0,10,.2)
for k in K:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
	t = time.time()
	#a = calculate_inf_sup_constant(gq, lq, bases, mus)
	a = calculate_inf_sup_constant2(gq, lq)
	b = calculate_continuity_constant(gq, lq)
	print time.time()-t, a
	A.append(a)
	B.append(b)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, B, label = "con-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, A, label = "inf-sup-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()


























from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)

import time

A = []
N = np.arange(0,10,1)
for n in N:
	print n
	bases = create_bases2(gq, lq, n, silent = False)
	t = time.time()
	a = calculate_inf_sup_constant(gq, lq, bases)
	print time.time()-t, a
	A.append(a)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(N, A, label = "inf-sup-constant")
plt.xlabel('n')
plt.legend(loc='upper right')
plt.show()





###
from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 10, silent = False)
A =[]
for space in gq["spaces"]:
	bases[space] = bases[space].empty()
	a = calculate_inf_sup_constant(gq, lq, bases)
	A.append(a)


from matplotlib import pyplot as plt
plt.figure()
plt.plot(A, label = "inf-sup-constant")
plt.xlabel('n')
plt.legend(loc='upper right')
plt.show()








isc2: 1





k=1
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
A1 = gq["d"].operator.assemble(mus)._matrix.todense()
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
A2 = gq["d"].operator.assemble(mus)._matrix.todense()




from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=20
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)

A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1
X = H1

a = gq["data"]['boundary_info'].dirichlet_boundaries(2)
b = np.arange(A.shape[0])
c = np.delete(b,a)

A = A[:,c][c,:]
X = X[:,c][c,:]
Y = Y[:,c][c,:]

Yinv = sp.factorized(Y)
def mv(v):
	return A.H.dot(Yinv(A.dot(v)))
M1 = LinearOperator(A.shape, matvec = mv)
print "trying"
eigs = sp.eigs(M1, M=X, k=1, tol = 1e-4)
e1 = np.zeros(H1.shape[0])
e1[c] = eigs[1][:,0].real
gq["d"].visualize(NumpyVectorArray(e1.T))
eigvals = eigs[0]
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
eigvals





















from pymor.discretizers.elliptic import discretize_elliptic_cg
from problems import *
from pymor.basic import *
import numpy as np
set_log_levels(levels={'pymor': 'WARN'})
p = helmholtz(boundary = 'robin')
resolution = 8
d, data = discretize_elliptic_cg(p, diameter=1./resolution)
k=5
cloc = -1j*k
cglob = -1j*k
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
u = d.solve(mus)
d.visualize(u)


U = u.empty()
for k in np.arange(1,201,1):
	print k
	cloc = -1j*k
	cglob = -1j*k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	U.append(d.solve(mus))
d.visualize(U, rescale_colorbars = True)

















#op = gq["op"]
mus = {'k': k, 'c_glob': 6., 'c_loc': 6.}
op = gq["d"].operator.assemble(mus)
rhs = gq["rhs"]
spaces = gq["spaces"]
localizer = gq["localizer"]
operator_reductor = LRBOperatorProjection(op, rhs, localizer, spaces, bases, spaces, bases)
A = operator_reductor.get_reduced_operator()._matrix

H10 = gq["h1_0_prod"]
operator_reductor0 = LRBOperatorProjection(H10, rhs, localizer, spaces, bases, spaces, bases)
Y = operator_reductor0.get_reduced_operator()._matrix
H1 = gq["h1_prod"]
operator_reductor = LRBOperatorProjection(H1, rhs, localizer, spaces, bases, spaces, bases)
X = operator_reductor.get_reduced_operator()._matrix

t = time.time()
Xinv = sp.inv(X)
print time.time() -t
t = time.time()
Yinv = sp.inv(Y)
print time.time() -t
t = time.time()
M = Xinv.dot(A.H).dot(Yinv).dot(A).todense()
print time.time() -t
t =time.time()
eigvals = np.linalg.eigvals(M)
print time.time() -t
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
result = eigvals[0]



t = time.time()
M = A.H.dot(Yinv).dot(A).todense()
print time.time() -t








A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1


t =time.time()
Yinv = sp.inv(X)
print time.time() -t
t =time.time()
M = A.H.dot(Yinv).dot(A)
print time.time() -t
t =time.time()
eigvals = sp.eigs(M, M=X, which = 'SM', tol = 1e-2)[0]
print time.time() -t
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
result = eigvals[0]






from scipy.sparse.linalg import LinearOperator
t = time.time()
Xinv = sp.factorized(X)
print time.time()-t
def mv(v):
	return A.H.dot(Xinv(A.dot(v)))
M1 = LinearOperator(A.shape, matvec = mv)
t =time.time()
eigvals = sp.eigs(M1, M=X, which = 'SM', tol = 1e-2)
print time.time() -t


A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1

M = A.T.dot(sp.inv(Y)).dot(A)

import time
t = time.time()
eigvals = sp.eigs(M, M=X, which = 'SM')[0]
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
print eigvals[0]














from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

bs = []
gs = []
ks = np.arange(0.1,10,.1)
for k in ks:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
	bases = create_bases2(gq, lq, 15, silent = False)
	op = gq["op"]
	rhs = gq["rhs"]
	localizer = gq["localizer"]
	spaces = gq["spaces"]
	operator_reductor = LRBOperatorProjection(op, rhs, localizer, spaces, bases, spaces, bases)
	A = operator_reductor.get_reduced_operator()._matrix

	H10 = gq["h1_0_prod"]
	operator_reductor = LRBOperatorProjection(H10, rhs, localizer, spaces, bases, spaces, bases)
	Y = operator_reductor.get_reduced_operator()._matrix
	H1 = gq["h1_prod"]
	operator_reductor = LRBOperatorProjection(H1, rhs, localizer, spaces, bases, spaces, bases)
	X = operator_reductor.get_reduced_operator()._matrix

	M = sp.inv(X).dot(A.T).dot(sp.inv(Y)).dot(A).todense()
	import time
	t = time.time()
	eigvals = np.linalg.eigvals(M)
	print time.time()-t
	eigvals = np.sqrt(np.abs(eigvals))
	eigvals.sort()
	b = eigvals[0]
	g = eigvals[len(eigvals)-1]
	print b
	print g
	bs.append(b)
	gs.append(g)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(ks, bs, label = "inf-sup-constant")
#plt.plot(ks, gs, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

plt.figure()
#plt.plot(ks, bs, label = "inf-sup-constant")
plt.plot(ks, gs, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()



plt.figure()
plt.plot(ks, qs, label = "quotients")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()













from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 15, silent = False)

A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1

Yinv = sp.inv(Y)
Xinv = sp.inv(X)
M1 = Xinv.dot(A.T)
M2 = Yinv.dot(A)
M = Xinv.dot(A.T).dot(Yinv).dot(A)







import time
t = time.time()
eigvals = sp.eigs(M, M=X)[0]
print time.time()-t

eigvals = np.sqrt(np.abs(eigvals))
eigvals[::-1].sort()
print eigvals[0]



M = Xinv.dot(A.T).dot(Yinv).dot(A)
t = time.time()
eigvals = np.linalg.eigvals(M)[0]
print time.time()-t


eigvals = np.sqrt(np.abs(eigvals))
eigvals[::-1].sort()
print eigvals[0]






from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=4
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 15, silent = False)

op = gq["op"]
rhs = gq["rhs"]
localizer = gq["localizer"]
spaces = gq["spaces"]
operator_reductor = LRBOperatorProjection(op, rhs, localizer, spaces, bases, spaces, bases)
A = operator_reductor.get_reduced_operator()._matrix

H10 = gq["h1_0_prod"]
operator_reductor = LRBOperatorProjection(H10, rhs, localizer, spaces, bases, spaces, bases)
Y = operator_reductor.get_reduced_operator()._matrix
H1 = gq["h1_prod"]
operator_reductor = LRBOperatorProjection(H1, rhs, localizer, spaces, bases, spaces, bases)
X = operator_reductor.get_reduced_operator()._matrix

M = sp.inv(X).dot(A.T).dot(sp.inv(Y)).dot(A).todense()
import time
t = time.time()
eigvals = np.linalg.eigvals(M)
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
print eigvals[0]





import scipy.sparse.linalg as sp
Yinv = sp.inv(Y)
M = A.T.dot(Yinv).dot(A)
import time
t = time.time()
eigvals = sp.eigs(M, M=X, which = 'SM', tol = 1e-1)[0]
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
print eigvals[0]





import scipy.sparse.linalg as sp





from problems import *
import numpy as np
from pymor.basic import *
set_log_levels(levels={'pymor': 'WARN'})
import scipy.sparse.linalg as sp

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

bs = []
gs = []
cs = []
ks = np.arange(0.1,5.0,.1)
for k in ks:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	diameter = 1./resolution
	d, data = discretize_elliptic_cg(p, diameter=diameter)
	A = d.operator.assemble(mus)._matrix
	H1 = d.products["h1"].assemble()._matrix
	H1_0 = d.products["h1_0"].assemble()._matrix
	Y = H1_0
	X = H1
	
	#A = np.abs(A)
	Yinv = sp.inv(Y)
	M = A.T.dot(Yinv).dot(A)
	eigvals = sp.eigs(M, M=X, which = 'SM', tol=1e-2, k=1)[0]
	eigvals = np.sqrt(np.abs(eigvals))
	eigvals[::1].sort()
	b = eigvals[0]
	bs.append(b)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(ks, bs, label = "inf-sup-constant")
#plt.plot(ks, gs, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()







from scipy.sparse.linalg import LinearOperator
def mv(v):
	return M.dot(v)

M1 = LinearOperator(M.shape, matvec = mv)

def mv1(v): 
	return X.dot(v)

M2 = LinearOperator(X.shape, matvec = mv1)


M1 = sp.aslinearoperator(M)
M2 = sp.aslinearoperator(X)

t = time.time()
eigvals = sp.eigs(M1, M=M2, which = 'SM', tol=1e-2)[0]
print time.time() -t










from problems import *
import numpy as np
from pymor.basic import *
set_log_levels(levels={'pymor': 'WARN'})
import scipy.sparse.linalg as sp

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k= 4
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
diameter = 1./resolution
d, data = discretize_elliptic_cg(p, diameter=diameter)
A = d.operator.assemble(mus)._matrix
H1 = d.products["h1"].assemble()._matrix
H1_0 = d.products["h1_0"].assemble()._matrix
Y = H1_0
X = H1

import time
t = time.time()
#A = np.abs(A)
Yinv = sp.inv(Y)
print time.time()-t
t = time.time()
M = A.T.dot(Yinv).dot(A)
print time.time()-t

t = time.time()
eigvals = sp.eigs(M, M=X, which = 'SM', tol = 1e-2, k=3)[0]
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
print eigvals[0]

g = eigvals[len(eigvals)-1]
c = g/b
print b
print g





import time
#A = np.abs(A)
t = time.time()
Yinv = sp.inv(Y).todense()
Xinv = sp.inv(X).todense()
print time.time()-t
t = time.time()
M = Xinv.dot(A.T).dot(Yinv).dot(A)
print time.time()-t
t = time.time()
eigvals = np.linalg.eigvals(M)
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
b = eigvals[0]
g = eigvals[len(eigvals)-1]
c = g/b
print b
print g
