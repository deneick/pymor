from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

num_testvecs= 20
boundary= 'neumann'
save = 'test3.dat'
cglob = 0
cloc = 0
k=2
plot = True
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
space = np.logspace(-15,0,10)
err = []
for prob in space:
	print prob
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus, calQ = True)
	d = gq["d"]
	u = d.solve(mus)
	bases = create_bases(gq, lq, num_testvecs, transfer = 'robin', target_accuracy = 1e-2, max_failure_probability = prob, calC = True)
	ru = reconstruct_solution(gq, lq, bases)
	err.append(d.h1_norm(u-ru)[0]/d.h1_norm(u)[0])
from matplotlib import pyplot as plt
plt.figure()
plt.loglog(space, err, label = "err")
plt.legend(loc='upper right')
plt.xlabel('prob')
plt.show()














from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary= 'robin'
cglob = -6j
cloc = 1.-.5j
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
resolution = 200
p = helmholtz(boundary = boundary)
space = [5, 8, 10, 20, 25, 40, 50]
err = []
for coarse_grid_resolution in space:
	print coarse_grid_resolution
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus)
	d = gq["d"]
	u = d.solve(mus)
	bases = create_bases2(gq, lq, 10, transfer = 'robin')
	ru = reconstruct_solution(gq, lq, bases)
	err.append(d.h1_norm(u-ru)[0]/d.h1_norm(u)[0])
from matplotlib import pyplot as plt
plt.figure()
plt.semilogy(space, err, label = "err")
plt.legend(loc='upper right')
plt.xlabel('cgr')
plt.show()























from problems import *
import numpy as np
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary= 'robin'
k=50
cloc0 = 0
cloc1 = 0.02*(5-1j)
cloc2 = 0.0016*(8-1j)
cloc = cloc0+ cloc1*k+cloc2*k**2
cglob = -1j*k
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
plot = True
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
space = np.arange(20,200,20)
err = []
for resolution in space:
	print resolution
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus = mus)
	d = gq["d"]
	u = d.solve(mus)
	E = []
	for i in range(10):
		bases = create_bases2(gq, lq, 30, transfer = 'robin')
		ru = reconstruct_solution(gq, lq, bases)
		E.append(d.h1_norm(u-ru)[0]/d.h1_norm(u)[0])
	err.append(E)
errs = np.mean(err, axis = 1)
from matplotlib import pyplot as plt
plt.figure()
plt.plot(space, errs, label = "err")
plt.legend(loc='upper right')
plt.xlabel('res')
plt.show()



























from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'neumann'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

import time

A = []
B = []
C = []
#D = []
K = np.arange(0,10,.1)
for k in K:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
	bases = create_bases2(gq, lq, 15, silent = False)
	t = time.time()
	a = calculate_inf_sup_constant(gq, lq, bases)
	print time.time()-t, a
	t = time.time()
	b = calculate_inf_sup_constant2(gq, lq)
	print time.time()-t, b
	t = time.time()
	c = calculate_continuity_constant(gq, lq)
	print time.time()-t, c
	#t = time.time()
	#d = calculate_continuity_constant2(gq, lq, bases)
	#print time.time()-t, d
	A.append(a)
	B.append(b)
	C.append(c)
	#D.append(d)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, A, label = "inf-sup-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

plt.figure()
plt.plot(K, B, label = "inf-sup-constant2")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

plt.figure()
plt.plot(K, C, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

"""
plt.figure()
plt.plot(K, D, label = "continuity-constant2")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()
"""





from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, A, label = "inf-sup-constant")
plt.plot(K, B, label = "inf-sup-constant2")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()










from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=0
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 15, silent = False)

import time

A = []
B = []
K = np.arange(0,10,.2)
for k in K:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
	t = time.time()
	#a = calculate_inf_sup_constant(gq, lq, bases, mus)
	a = calculate_inf_sup_constant2(gq, lq)
	b = calculate_continuity_constant(gq, lq)
	print time.time()-t, a
	A.append(a)
	B.append(b)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, B, label = "con-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

from matplotlib import pyplot as plt
plt.figure()
plt.plot(K, A, label = "inf-sup-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()


























from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)

import time

A = []
N = np.arange(0,10,1)
for n in N:
	print n
	bases = create_bases2(gq, lq, n, silent = False)
	t = time.time()
	a = calculate_inf_sup_constant(gq, lq, bases)
	print time.time()-t, a
	A.append(a)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(N, A, label = "inf-sup-constant")
plt.xlabel('n')
plt.legend(loc='upper right')
plt.show()





###
from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 10, silent = False)
A =[]
for space in gq["spaces"]:
	bases[space] = bases[space].empty()
	a = calculate_inf_sup_constant(gq, lq, bases)
	A.append(a)


from matplotlib import pyplot as plt
plt.figure()
plt.plot(A, label = "inf-sup-constant")
plt.xlabel('n')
plt.legend(loc='upper right')
plt.show()








isc2: 1





k=1
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
A1 = gq["d"].operator.assemble(mus)._matrix.todense()
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
A2 = gq["d"].operator.assemble(mus)._matrix.todense()




from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=2
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)

A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1
"""
a = gq["data"]['boundary_info'].dirichlet_boundaries(2)
b = np.arange(A.shape[0])
c = np.delete(b,a)

A = A[:,c][c,:]
X = X[:,c][c,:]
Y = Y[:,c][c,:]
"""
Yinv = sp.factorized(Y)
def mv(v):
	return A.H.dot(Yinv(A.dot(v)))
M1 = LinearOperator(A.shape, matvec = mv)
print "trying"
eigs = sp.eigs(M1, M=X, which = 'SM', tol = 1e-1, k=100)
e1 = np.zeros(H1.shape[0])
e1[c] = eigs[1][:,0].real
gq["d"].visualize(NumpyVectorArray(e1.T))
eigvals = eigs[0]
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
eigvals





















from pymor.discretizers.elliptic import discretize_elliptic_cg
from problems import *
from pymor.basic import *
import numpy as np
set_log_levels(levels={'pymor': 'WARN'})
p = helmholtz(boundary = 'robin')
resolution = 8
d, data = discretize_elliptic_cg(p, diameter=1./resolution)
k=5
cloc = -1j*k
cglob = -1j*k
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
u = d.solve(mus)
d.visualize(u)


U = u.empty()
for k in np.arange(1,201,1):
	print k
	cloc = -1j*k
	cglob = -1j*k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	U.append(d.solve(mus))
d.visualize(U, rescale_colorbars = True)

















#op = gq["op"]
mus = {'k': k, 'c_glob': 6., 'c_loc': 6.}
op = gq["d"].operator.assemble(mus)
rhs = gq["rhs"]
spaces = gq["spaces"]
localizer = gq["localizer"]
operator_reductor = LRBOperatorProjection(op, rhs, localizer, spaces, bases, spaces, bases)
A = operator_reductor.get_reduced_operator()._matrix

H10 = gq["h1_0_prod"]
operator_reductor0 = LRBOperatorProjection(H10, rhs, localizer, spaces, bases, spaces, bases)
Y = operator_reductor0.get_reduced_operator()._matrix
H1 = gq["h1_prod"]
operator_reductor = LRBOperatorProjection(H1, rhs, localizer, spaces, bases, spaces, bases)
X = operator_reductor.get_reduced_operator()._matrix

t = time.time()
Xinv = sp.inv(X)
print time.time() -t
t = time.time()
Yinv = sp.inv(Y)
print time.time() -t
t = time.time()
M = Xinv.dot(A.H).dot(Yinv).dot(A).todense()
print time.time() -t
t =time.time()
eigvals = np.linalg.eigvals(M)
print time.time() -t
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
result = eigvals[0]



t = time.time()
M = A.H.dot(Yinv).dot(A).todense()
print time.time() -t








A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1


t =time.time()
Yinv = sp.inv(X)
print time.time() -t
t =time.time()
M = A.H.dot(Yinv).dot(A)
print time.time() -t
t =time.time()
eigvals = sp.eigs(M, M=X, which = 'SM', tol = 1e-2)[0]
print time.time() -t
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
result = eigvals[0]






from scipy.sparse.linalg import LinearOperator
t = time.time()
Xinv = sp.factorized(X)
print time.time()-t
def mv(v):
	return A.H.dot(Xinv(A.dot(v)))
M1 = LinearOperator(A.shape, matvec = mv)
t =time.time()
eigvals = sp.eigs(M1, M=X, which = 'SM', tol = 1e-2)
print time.time() -t


A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1

M = A.T.dot(sp.inv(Y)).dot(A)

import time
t = time.time()
eigvals = sp.eigs(M, M=X, which = 'SM')[0]
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals.sort()
print eigvals[0]














from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

bs = []
gs = []
ks = np.arange(0.1,10,.1)
for k in ks:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
	bases = create_bases2(gq, lq, 15, silent = False)
	op = gq["op"]
	rhs = gq["rhs"]
	localizer = gq["localizer"]
	spaces = gq["spaces"]
	operator_reductor = LRBOperatorProjection(op, rhs, localizer, spaces, bases, spaces, bases)
	A = operator_reductor.get_reduced_operator()._matrix

	H10 = gq["h1_0_prod"]
	operator_reductor = LRBOperatorProjection(H10, rhs, localizer, spaces, bases, spaces, bases)
	Y = operator_reductor.get_reduced_operator()._matrix
	H1 = gq["h1_prod"]
	operator_reductor = LRBOperatorProjection(H1, rhs, localizer, spaces, bases, spaces, bases)
	X = operator_reductor.get_reduced_operator()._matrix

	M = sp.inv(X).dot(A.T).dot(sp.inv(Y)).dot(A).todense()
	import time
	t = time.time()
	eigvals = np.linalg.eigvals(M)
	print time.time()-t
	eigvals = np.sqrt(np.abs(eigvals))
	eigvals.sort()
	b = eigvals[0]
	g = eigvals[len(eigvals)-1]
	print b
	print g
	bs.append(b)
	gs.append(g)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(ks, bs, label = "inf-sup-constant")
#plt.plot(ks, gs, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()

plt.figure()
#plt.plot(ks, bs, label = "inf-sup-constant")
plt.plot(ks, gs, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()



plt.figure()
plt.plot(ks, qs, label = "quotients")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()













from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)
k=6
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 15, silent = False)

A = gq["op"]._matrix
H1 = gq["h1_prod"]._matrix
H1_0 = gq["h1_0_prod"]._matrix
Y = H1_0
X = H1

Yinv = sp.inv(Y)
Xinv = sp.inv(X)
M1 = Xinv.dot(A.T)
M2 = Yinv.dot(A)
M = Xinv.dot(A.T).dot(Yinv).dot(A)







import time
t = time.time()
eigvals = sp.eigs(M, M=X)[0]
print time.time()-t

eigvals = np.sqrt(np.abs(eigvals))
eigvals[::-1].sort()
print eigvals[0]



M = Xinv.dot(A.T).dot(Yinv).dot(A)
t = time.time()
eigvals = np.linalg.eigvals(M)[0]
print time.time()-t


eigvals = np.sqrt(np.abs(eigvals))
eigvals[::-1].sort()
print eigvals[0]






from problems import *
import numpy as np
import sys
from pymor.basic import *
from localize_problem import *
from constants import *
from generate_solution import *

set_log_levels(levels={'pymor': 'WARN'})

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k=4
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
gq, lq = localize_problem(p, coarse_grid_resolution, resolution, mus)
bases = create_bases2(gq, lq, 15, silent = False)

op = gq["op"]
rhs = gq["rhs"]
localizer = gq["localizer"]
spaces = gq["spaces"]
operator_reductor = LRBOperatorProjection(op, rhs, localizer, spaces, bases, spaces, bases)
A = operator_reductor.get_reduced_operator()._matrix

H10 = gq["h1_0_prod"]
operator_reductor = LRBOperatorProjection(H10, rhs, localizer, spaces, bases, spaces, bases)
Y = operator_reductor.get_reduced_operator()._matrix
H1 = gq["h1_prod"]
operator_reductor = LRBOperatorProjection(H1, rhs, localizer, spaces, bases, spaces, bases)
X = operator_reductor.get_reduced_operator()._matrix

M = sp.inv(X).dot(A.T).dot(sp.inv(Y)).dot(A).todense()
import time
t = time.time()
eigvals = np.linalg.eigvals(M)
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
print eigvals[0]





import scipy.sparse.linalg as sp
Yinv = sp.inv(Y)
M = A.T.dot(Yinv).dot(A)
import time
t = time.time()
eigvals = sp.eigs(M, M=X, which = 'SM', tol = 1e-1)[0]
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
print eigvals[0]





import scipy.sparse.linalg as sp





from problems import *
import numpy as np
from pymor.basic import *
set_log_levels(levels={'pymor': 'WARN'})
import scipy.sparse.linalg as sp

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

bs = []
gs = []
cs = []
ks = np.arange(0.1,5.0,.1)
for k in ks:
	print k
	mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
	diameter = 1./resolution
	d, data = discretize_elliptic_cg(p, diameter=diameter)
	A = d.operator.assemble(mus)._matrix
	H1 = d.products["h1"].assemble()._matrix
	H1_0 = d.products["h1_0"].assemble()._matrix
	Y = H1_0
	X = H1
	
	#A = np.abs(A)
	Yinv = sp.inv(Y)
	M = A.T.dot(Yinv).dot(A)
	eigvals = sp.eigs(M, M=X, which = 'SM', tol=1e-2, k=1)[0]
	eigvals = np.sqrt(np.abs(eigvals))
	eigvals[::1].sort()
	b = eigvals[0]
	bs.append(b)

from matplotlib import pyplot as plt
plt.figure()
plt.plot(ks, bs, label = "inf-sup-constant")
#plt.plot(ks, gs, label = "continuity-constant")
plt.xlabel('k')
plt.legend(loc='upper right')
plt.show()







from scipy.sparse.linalg import LinearOperator
def mv(v):
	return M.dot(v)

M1 = LinearOperator(M.shape, matvec = mv)

def mv1(v): 
	return X.dot(v)

M2 = LinearOperator(X.shape, matvec = mv1)


M1 = sp.aslinearoperator(M)
M2 = sp.aslinearoperator(X)

t = time.time()
eigvals = sp.eigs(M1, M=M2, which = 'SM', tol=1e-2)[0]
print time.time() -t










from problems import *
import numpy as np
from pymor.basic import *
set_log_levels(levels={'pymor': 'WARN'})
import scipy.sparse.linalg as sp

boundary = 'dirichlet'
cglob= 6
cloc=6.
resolution = 50
coarse_grid_resolution = 10
p = helmholtz(boundary = boundary)

k= 4
mus = {'k': k, 'c_glob': cglob, 'c_loc': cloc}
diameter = 1./resolution
d, data = discretize_elliptic_cg(p, diameter=diameter)
A = d.operator.assemble(mus)._matrix
H1 = d.products["h1"].assemble()._matrix
H1_0 = d.products["h1_0"].assemble()._matrix
Y = H1_0
X = H1

import time
t = time.time()
#A = np.abs(A)
Yinv = sp.inv(Y)
print time.time()-t
t = time.time()
M = A.T.dot(Yinv).dot(A)
print time.time()-t

t = time.time()
eigvals = sp.eigs(M, M=X, which = 'SM', tol = 1e-2, k=3)[0]
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
print eigvals[0]

g = eigvals[len(eigvals)-1]
c = g/b
print b
print g





import time
#A = np.abs(A)
t = time.time()
Yinv = sp.inv(Y).todense()
Xinv = sp.inv(X).todense()
print time.time()-t
t = time.time()
M = Xinv.dot(A.T).dot(Yinv).dot(A)
print time.time()-t
t = time.time()
eigvals = np.linalg.eigvals(M)
print time.time()-t
eigvals = np.sqrt(np.abs(eigvals))
eigvals[::1].sort()
b = eigvals[0]
g = eigvals[len(eigvals)-1]
c = g/b
print b
print g
